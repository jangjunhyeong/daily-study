/* 
  work .1 -2.html 파일에서 작성된 거추장스러운 코드들을 모두 걷어내고 핵심 알고리즘만 따로 떼어내었다.

  pseudo .1 startTimer, endTimer 두개의 setInterval()작업이 작성되어있다.
  pseudo .2 코드상으로는 startTimer가 얼마간의 실행을 하고 종료 한 뒤,
  pseudo .3 endTimer가 실행되는 순서로 확인 할 수 있다.(startTimer가 endTimer보다 먼저작성되어있기 때문)

  * setInterval(), setTimeout이 아닌 다른 함수라면 위의 예상에 맞게 실행되어 순차적으로 알고리즘이 동작했을 것이다. 
  * 순차적으로 = 동기적으로
  * 
  * 하지만 setInterval(), setTimeout()은 기본 설정상 "순차적이지 않게 동작하라"는 로직이 들어있기 때문에 아래의 코드는 읽는 순서대로 반응하지 않는다.
  * 이것을 비동기적 이라고 한다. 
  * 장점 : 여러가지 일을 동시에 처리해야 할때 매우 유용하다.
  * 단점 : 여러가지 일을 순서에 맞게 처리해야할때 난감하다.
  * 
  * 개발 실무에서는 아래와 같은 상황에서 동기, 비동기 제어를 진행한다.
  
  ? 웹사이트 방문자가 한번에 여럿이 데이터를 요구할경우 -> 빠르게 끝낼 알고리즘 부터 우선 처리하는 비동기 방식을 채택한다.
  ? 순번에 맞게 자동 동작해야 하는 경우(웹 모션등등) -> 자동동작을 '멈추게' 하는 일련의 공정을 거쳐 동기방식으로 제어하게끔 채택한다.
  todo : '원하는대로 동작'하지 않을때 이해해야 하는 동기, 비동기 방식
  todo : 값을 판단하는 방식과 다르다.
  * -2.html 파일에서는 값을 판단하는 방식으로 비동기 방식을 제어했다.
  * isStatus가 비동기, 동기 방식을 제어한 것이 아닌 '조건' 방식으로 제어했다.
  * 따라서 -2.html 파일은 순서대로 움직인 것 같이 보이지만,
  * 사실은 두개의 이벤트가 동시에 시작했고 단지 조건이 맞지 않은 실행함수는 무시되었을 뿐이다.
  * 값을 통한 조건 제어 방식의 한계점은 '가독성'에 있다. 번거로운 변수를 생성하여 제어해야 하고, 로직이 복잡해질경우 더 많은 변수나 제어가 필요하다.
  * 하지만 promise와 같은 실행 순서를 제어하는 문법을 사용한다면, 불필요한 변수사용을 줄일 수 있기 때문에 매우 유용하다. 
  * 더 나아가서는 'promise' 문법 자체가 '나는 지금 이 코드에 대해 동작을 제어할 거야' 라는 메세지를 전하기 때문에 유지보수 측면에서도 중요한 부분이라 할 수 있다.

  ! 아래의 알고리즘은 제대로 동작하지 않으니 주의 할 것

*/
// ! initialize
let y = 0;

// ? first event
let startTimer = setInterval(() => {
  if(y < 10) {
    y++;
    console.log(`startTimer가 ${y+1}번째 실행되었습니다.`);
  } else {
    y = 10;
    console.log(`startTimer가 실행횟수를 모두 충족하여 종료하였습니다`);
    clearInterval(startTimer);
  }
},16);
// ? second event
let endTimer = setInterval(() => {
  if(y > 0) {
    y--;
    console.log(`endTimer가 실행횟수${-(y+1)}만큼 실행되었습니다.`);
  } else {
    console.log(`endTimer가 실행횟수를 모두 충족하여 종료하였습니다`);
    clearInterval(endTimer);
  }
},16);