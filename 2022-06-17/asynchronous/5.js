/*
  ? Promise 객체 설명
  * 직역하면 '약속' 이라는 그 뜻처럼 
  * "마음대로 움직이는 실행방식바꾸어 제어할 수 있도록 약속을 만든다" 라고 비유할 수 있겠다.
  * 약속이 걸린 코드는 자기맘대로 행동하지 않고, 제어에 따라 움직인다.
  * 약속을 거는 방식은 생성자 함수(거푸집)에서 찍어낸 인스턴스(특정값) 처럼 보이는
  * new Promise(); 라는 방식으로 '약속'을 만들어낸다.
  ? 즉, new Promise(); 안에 담긴 코드는 '제멋대로 실행되지 않는다' 라고 할수 있다.

  * new Promise();는 매개변수로 addEventListener처럼 콜백함수를 받는 구조인데,
  * addEventListener("type", function(event) {}) 에서 만드는 '이벤트 객체(event object)' 처럼 특수한 매개변수를 자동으로 갖는다.
  * 관습적으로 resolve 라는 첫번째 매개변수, reject 라는 두번째 매개변수가 그것이다.
  * resolve : 귀결되다 이행되다 성공했다로 풀이할수 있다.
  * reject : 거부했다 실행되지 않았다로 풀이할 수 있다.
  * 설명상 resolve를 '성공', reject를 '실패'로 부르는 경우가 많다.
  * 
  * 약속을 제어하는 Promise는 제멋대로 실행되지 않기 때문에 대기상태가 된다. 코드를 작성하는 제작자가 실행을 '수동'으로 시키지 않으면 무한히 실행할 코드를 쥐어둔채로 대기한다.
  * 대기 한다라는 뜻으로 pending(팬딩) 상태다 라고 말한다.
  todo : 일반적인 코드는 '읽히자마자' 동기든 비동기든 어떠한 방식으로든 자동 실행되는 점과 매우 대조된다.
  todo : promise로 '감싸진' 코드는 읽혀도 대기한다.

  * 대기 상태에서 '어떤 지시를 기다리는데' 그것이 resolve() 와 reject()이다.
  * 성공했을때, 혹은 순서대로 진행되어야 할때는 resolve()를 호출하면 '어떤 동작을 실행하고 다음순서에 할일 을 넘긴다'
  * 비유하면 '종소리가 울렸을때 석식먹으러 뛰어가는 학생을 떠올려 볼 수 있다.'
  * 성공하지 않았을때인 reject()는 통신과 같은 변수를 대비하기 위해 만들어진 함수이며 resolve()처럼 무언가의 실행을 제어하는 일종이다.
  * 인터넷 글이나 책에서는 이러한것을 
  * resolve() -> fulfilled 이행했다. 라고 표현한다.
  * reject() -> rejected 거부했다. 라고 표현한다.
  * 
  * 다음 행동을 할 코드를 .then()이라는 함수 연결을 통해 붙이는 방식을 취한다.
  * 아래의 예시로 보았을때 코드는 콜백함수로 구현한 것보다 상당히 길어졌지만, 코드가 길어질수록 아래와 같은 방식이 유지보수 및 동작제어에 압도적으로 유리하다.
  * 
  * 특히 인터렉션(사용자의 행동에 맞추어 순서를 제어해야하는경우)에서 그 빛을 발휘한다.
*/

let y = 0;

function orderAction(y) {
  return new Promise((resolve, reject) => {
    resolve(y); // ? 성공했을때 호출하는 resolve() 함수에 어떤 값을 담은 매개변수 y값을 담았다.
  });
}

orderAction(y)
  .then((y) => {
    return new Promise((resolve, reject) => {
      resolve(y); // ? 위에서 담긴 매개변수 y값을 또한번 담아 다음순서에 넘긴다.
    });
  })
  .then((y) => {
    return new Promise((resolve, reject) => {
      resolve(y); //? 결과적으로 의미 없는 코드이지만 위의 .then에서 무언가 넘겨받은 값을 받았다.
    });
  });

  /*
    ? 값을 넘긴다. 값을 받았다. 라는 어휘
    * y라는 값이 0이라는 값을 가지고 있는데 어떤 순서에 의해 변형되거나 바뀐다. 바뀐 값을 다음 순서에 넘긴다고 표현하는데,
    * 콜백함수의 매개변수를 떠올리는 것이 좋다.
    * addEventListener('wheel', function(e) {});
    * 이벤트 메서드에서 e는 wheel 이 가진 데이터(객체)를 넘겨받은 맥락이다.
    * 마치 축구선수가 공을 패스하듯 '다루고자 하는 데이터를' 이리저리 전달하는 개념이다.
    * 
    * 값을 수고스럽게 전달하면서 진행하는 이유는, '순서'를 제어하기 위함에 있다.
    * 
    * 


  
  
  
  */